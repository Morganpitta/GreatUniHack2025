{% extends "base.html" %}

{% block content %}
    <style>
        /* This style block can be inside or outside the block content, but here is fine. */
        canvas { background-color: #000; border: 1px solid #444; }
        p { margin-top: 20px; text-align: center; }
    </style>
    
    <canvas id="visualizationCanvas" width="800" height="600"></canvas>
    <p>Hover over a planet to learn more. Click the background to regenerate the layout.</p>

    <!-- Include the Socket.IO client library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // --- 1. SETUP ---
            const canvas = document.getElementById('visualizationCanvas');
            const ctx = canvas.getContext('2d');

            // --- WEBSOCKET SETUP ---
            const socket = io.connect('http://' + document.domain + ':' + location.port);

            socket.on('connect', function() {
                // Tell the server this client is viewing the graph
                socket.emit('join_graph');
            });

            window.onbeforeunload = function() {
                // Tell the server this client is leaving the graph page
                socket.emit('leave_graph');
            };

            // --- 2. DATA LOADING ---
            let data;
            try {
                data = JSON.parse('{{ chart_data|safe }}');
            }
            catch (e) {
                console.error("Failed to parse data from Flask:", e);
                ctx.fillStyle = 'red';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Error: Could not load data.', canvas.width / 2, canvas.height / 2);
                return;
            }

            // --- 3. CONFIGURATION ---
            const pointRadius = 32;
            const solidLineThreshold = 350;
            const dottedLineThreshold = 500;
            const minimumNodeDistance = 150;
            const maxPlacementAttempts = 100;
            const numberOfTextureDots = 50;
            const numberOfStars = 300;
            const starColors = ['#FFFFFF', '#FFFFE0', '#ADD8E6', '#FFFAF0'];
            const maxMoonsPerPlanet = 4;
            const moonColors = ['#E5E4E2', '#C0C0C0', '#A9A9A9'];
            const cometSpeed = 2;
            const cometTailLength = 100;
            const cometColors = ['#FF6600', '#FF4500', '#000000', '#FF8C00'];

            let points = [];
            let stars = [];
            let comet = {};
            let pulses = []; // Array to hold the green message "blobs"

            // --- 4. FUNCTIONS ---

            function generateStars() {
                stars = [];
                for (let i = 0; i < numberOfStars; i++) {
                    stars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        radius: Math.random() * 1.5,
                        color: starColors[Math.floor(Math.random() * starColors.length)]
                    });
                }
            }

            function drawStars() {
                ctx.save();
                stars.forEach(star => {
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                    ctx.fillStyle = star.color;
                    ctx.fill();
                });
                ctx.restore();
            }

            function generateComet() {
                const side = Math.floor(Math.random() * 4);
                let x, y;
                if (side === 0) { x = Math.random() * canvas.width; y = -50; }
                else if (side === 1) { x = canvas.width + 50; y = Math.random() * canvas.height; }
                else if (side === 2) { x = Math.random() * canvas.width; y = canvas.height + 50; }
                else { x = -50; y = Math.random() * canvas.height; }

                const targetX = canvas.width / 2 + (Math.random() - 0.5) * 400;
                const targetY = canvas.height / 2 + (Math.random() - 0.5) * 400;
                const angle = Math.atan2(targetY - y, targetX - x);

                comet = {
                    x: x, y: y,
                    dx: Math.cos(angle) * cometSpeed,
                    dy: Math.sin(angle) * cometSpeed,
                    tail: []
                };
            }

            function drawComet() {
                if (!comet.x) return;
                comet.x += comet.dx;
                comet.y += comet.dy;
                comet.tail.unshift({ x: comet.x, y: comet.y });
                if (comet.tail.length > cometTailLength) {
                    comet.tail.pop();
                }

                ctx.save();
                for (let i = 0; i < comet.tail.length; i++) {
                    let p = comet.tail[i];
                    const alpha = (comet.tail.length - i) / comet.tail.length;
                    const radius = alpha * 2.5;

                    ctx.beginPath();
                    ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = cometColors[i % cometColors.length];
                    ctx.globalAlpha = alpha;
                    ctx.fill();
                }
                ctx.restore();

                if (comet.x < -100 || comet.x > canvas.width + 100 || comet.y < -100 || comet.y > canvas.height + 100) {
                    generateComet();
                }
            }

            function getDistance(p1, p2) {
                return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
            }
            
            // --- NEW: Functions for the message activity blobs ---
            function createPulse(senderLocation, receiverLocation) {
                const startPlanet = points.find(p => p.name.toLowerCase() === senderLocation);
                const endPlanet = points.find(p => p.name.toLowerCase() === receiverLocation);

                if (startPlanet && endPlanet) {
                    pulses.push({
                        startX: startPlanet.x,
                        startY: startPlanet.y,
                        endX: endPlanet.x,
                        endY: endPlanet.y,
                        startcolor:startPlanet.color,
                        endcolor:endPlanet.color,
                        progress: 0,
                        speed: 0.01 // Adjust speed of the blob
                    });
                }
            }
            
            function hexToRGB(hex, alpha) {
                var r = parseInt(hex.slice(1, 3), 16),
                    g = parseInt(hex.slice(3, 5), 16),
                    b = parseInt(hex.slice(5, 7), 16);
                if (alpha) {
                    return "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")";
                } else {
                    return "rgb(" + r + ", " + g + ", " + b + ")";
                }
            }

            function updateAndDrawPulses() {
                for (let i = pulses.length - 1; i >= 0; i--) {
                    const p = pulses[i];
                    p.progress += p.speed;

                    if (p.progress >= 1) {
                        pulses.splice(i, 1);
                        continue;
                    }

                    const currentX = p.startX + (p.endX - p.startX) * p.progress;
                    const currentY = p.startY + (p.endY - p.startY) * p.progress;

                    ctx.save();
                    const pulseRadius = 7;
                    const gradient = ctx.createRadialGradient(currentX, currentY, 0, currentX, currentY, pulseRadius);
                    gradient.addColorStop(0, hexToRGB(p.startcolor));
                    gradient.addColorStop(0.7, hexToRGB(p.startcolor, 0.5));
                    gradient.addColorStop(1, hexToRGB(p.endcolor, 1));
                    
                    ctx.beginPath();
                    ctx.arc(currentX, currentY, pulseRadius, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    ctx.restore();
                }
            }
            // --- End of new functions ---

            function generatePointPositions() {
                if (hoveredPlanet){
                    return;
                }
                points = [];
                data.forEach(item => {
                    let newPoint;
                    let isValidPosition = false;
                    let attempts = 0;
                    while (!isValidPosition && attempts < maxPlacementAttempts) {
                        newPoint = {
                            name: item.name, color: item.color,
                            x: pointRadius + Math.random() * (canvas.width - pointRadius * 2),
                            y: pointRadius + Math.random() * (canvas.height - pointRadius * 2),
                            moons: []
                        };
                        isValidPosition = true;
                        for (const existingPoint of points) {
                            if (getDistance(newPoint, existingPoint) < minimumNodeDistance) {
                                isValidPosition = false; break;
                            }
                        }
                        attempts++;
                    }
                    const moonCount = Math.floor(Math.random() * (maxMoonsPerPlanet + 1));
                    for (let i = 0; i < moonCount; i++) {
                        newPoint.moons.push({
                            orbitRadius: pointRadius + 10 + Math.random() * 20,
                            angle: Math.random() * Math.PI * 2,
                            speed: (Math.random() - 0.5) * 0.02,
                            radius: Math.random() * 2 + 1,
                            color: moonColors[Math.floor(Math.random() * moonColors.length)]
                        });
                    }
                    points.push(newPoint);
                });
            }

            function drawConnections() {
                for (let i = 0; i < points.length; i++) {
                    for (let j = i + 1; j < points.length; j++) {
                        const distance = getDistance(points[i], points[j]);
                        ctx.lineWidth = 1.5; ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                        if (distance < solidLineThreshold) {
                            ctx.beginPath(); ctx.setLineDash([]);
                            ctx.moveTo(points[i].x, points[i].y); ctx.lineTo(points[j].x, points[j].y); ctx.stroke();
                        } else if (distance < dottedLineThreshold) {
                            ctx.beginPath(); ctx.setLineDash([5, 10]);
                            ctx.moveTo(points[i].x, points[i].y); ctx.lineTo(points[j].x, points[j].y); ctx.stroke();
                        }
                    }
                }
            }

            function drawPoints() {
                points.forEach(point => {
                    const gradient = ctx.createRadialGradient(point.x - pointRadius * 0.3, point.y - pointRadius * 0.3, pointRadius * 0.1, point.x, point.y, pointRadius);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
                    gradient.addColorStop(0.8, point.color);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, pointRadius, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();

                    for (let i = 0; i < numberOfTextureDots; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * pointRadius;
                        const x = point.x + Math.cos(angle) * radius;
                        const y = point.y + Math.sin(angle) * radius;
                        ctx.beginPath();
                        ctx.arc(x, y, Math.random() * 2, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                        ctx.fill();
                    }
                    ctx.fillStyle = '#fff'; ctx.font = '16px Arial'; ctx.textAlign = 'center';
                    ctx.shadowColor = 'black'; ctx.shadowBlur = 5;
                    
                    ctx.fillText(String(point.name).charAt(0).toUpperCase() + String(point.name).slice(1), point.x, point.y - pointRadius - 12);
                    ctx.shadowBlur = 0;
                });
            }

            function drawMoons() {
                points.forEach(point => {
                    point.moons.forEach(moon => {
                        moon.angle += moon.speed;
                        const moonX = point.x + moon.orbitRadius * Math.cos(moon.angle);
                        const moonY = point.y + moon.orbitRadius * Math.sin(moon.angle);
                        ctx.beginPath();
                        ctx.arc(moonX, moonY, moon.radius, 0, Math.PI * 2);
                        ctx.fillStyle = moon.color;
                        ctx.fill();
                    });
                });
            }

            function drawHoverEffect() {
                if (hoveredPlanet) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(hoveredPlanet.x, hoveredPlanet.y, pointRadius + 10, 0, Math.PI * 2);
                    const gradient = ctx.createRadialGradient(hoveredPlanet.x, hoveredPlanet.y, pointRadius, hoveredPlanet.x, hoveredPlanet.y, pointRadius + 10);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.5)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            function drawInfoBox() {
                if (hoveredPlanet && hoveredPlanet.description) {
                    const text = hoveredPlanet.description;
                    const maxWidth = 200;
                    const lineHeight = 20;
                    const padding = 10;
                    const cornerRadius = 5;

                    ctx.font = '14px Arial';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'top';

                    const words = text.split(' ');
                    let line = '';
                    let lines = [];
                    for (let n = 0; n < words.length; n++) {
                        let testLine = line + words[n] + ' ';
                        let metrics = ctx.measureText(testLine);
                        if (metrics.width > maxWidth && n > 0) {
                            lines.push(line);
                            line = words[n] + ' ';
                        } else {
                            line = testLine;
                        }
                    }
                    lines.push(line);

                    const boxHeight = lines.length * lineHeight + (padding * 2);
                    const boxWidth = maxWidth + (padding * 2);
                    
                    let finalBoxX = hoveredPlanet.x + pointRadius + 15;
                    let finalBoxY = hoveredPlanet.y - boxHeight / 2;
                    if (finalBoxX + boxWidth > canvas.width) {
                        finalBoxX = hoveredPlanet.x - pointRadius - 15 - boxWidth;
                    }
                    if (finalBoxY < 0) { finalBoxY = padding; }
                    if (finalBoxY + boxHeight > canvas.height) { finalBoxY = canvas.height - boxHeight - padding; }

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(finalBoxX + cornerRadius, finalBoxY);
                    ctx.lineTo(finalBoxX + boxWidth - cornerRadius, finalBoxY);
                    ctx.quadraticCurveTo(finalBoxX + boxWidth, finalBoxY, finalBoxX + boxWidth, finalBoxY + cornerRadius);
                    ctx.lineTo(finalBoxX + boxWidth, finalBoxY + boxHeight - cornerRadius);
                    ctx.quadraticCurveTo(finalBoxX + boxWidth, finalBoxY + boxHeight, finalBoxX + boxWidth - cornerRadius, finalBoxY + boxHeight);
                    ctx.lineTo(finalBoxX + cornerRadius, finalBoxY + boxHeight);
                    ctx.quadraticCurveTo(finalBoxX, finalBoxY + boxHeight, finalBoxX, finalBoxY + boxHeight - cornerRadius);
                    ctx.lineTo(finalBoxX, finalBoxY + cornerRadius);
                    ctx.quadraticCurveTo(finalBoxX, finalBoxY, finalBoxX + cornerRadius, finalBoxY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    ctx.fillStyle = '#FFFFFF';
                    for (let i = 0; i < lines.length; i++) {
                        ctx.fillText(lines[i], finalBoxX + padding, finalBoxY + padding + (i * lineHeight));
                    }

                } else if (hoveredPlanet && hoveredPlanet.isLoading) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText("Loading...", hoveredPlanet.x, hoveredPlanet.y + pointRadius + 20);
                }
            }

            // --- 5. ANIMATION LOOP ---
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawStars();
                drawComet();
                drawConnections();
                updateAndDrawPulses(); // Draw the message blobs each frame
                drawPoints();
                drawMoons();
                drawHoverEffect();
                drawInfoBox();

                canvas.style.cursor = hoveredPlanet ? 'pointer' : 'default';

                requestAnimationFrame(animate);
            }

            function fetchPlanetInfo(planet) {
                if (planet.isLoading || planet.description) {
                    return;
                }
                planet.isLoading = true;
                fetch(`/hover/${encodeURIComponent(planet.name)}`)
                    .then(response => response.json())
                    .then(data => {
                        planet.description = data.response;
                        planet.isLoading = false;
                    })
                    .catch(error => {
                        console.error('Error fetching planet info:', error);
                        planet.description = "Could not load information.";
                        planet.isLoading = false;
                    });
            }

            // --- 6. INITIALIZATION & EVENT LISTENERS ---
            let hoveredPlanet = null;
            let lastHoveredPlanet = null;

            generateStars();
            generateComet();
            generatePointPositions();
            animate();

            // --- NEW: WebSocket listener for message activity ---
            socket.on('new_message_activity', function(data) {
                console.log('New message activity received:', data);
                createPulse(data.sender_location, data.receiver_location);
            });
            
            function handleMouseMove(e) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                hoveredPlanet = null;
                for (const point of points) {
                    const distance = getDistance({x: mouseX, y: mouseY}, point);
                    if (distance < pointRadius) {
                        hoveredPlanet = point;
                        break;
                    }
                }

                if (hoveredPlanet && hoveredPlanet !== lastHoveredPlanet) {
                    fetchPlanetInfo(hoveredPlanet);
                }
                lastHoveredPlanet = hoveredPlanet;
            }

            canvas.addEventListener('click', generatePointPositions);
            canvas.addEventListener('mousemove', handleMouseMove);
        });
    </script>

{% endblock %}